<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>滑轮</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        canvas {
            border: 1px solid #f00;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>
    
    https://www.cnblogs.com/zhaojz/p/4218026.html
    https://www.cnblogs.com/zhaojz/p/4218031.html
<script>
    function getAngle(x, y) {
        let hypotenuse = Math.sqrt(Math.pow(x, 2)+Math.pow(y, 2));
        //斜边长度
        let cos = x/hypotenuse;
        let radian = Math.acos(cos);
        //求出弧度
        let angle = 180/(Math.PI/radian);
        //用弧度算出角度
        if (y < 0) {
            angle = -angle;
        } else if ((y == 0) && (x < 0)) {
            angle = 180;
        }
        if (x > 0) {
            if (y > 0) {
                // 1
                // console.log('=1')
                return 90 - angle
            } else {
                // 2
                // console.log('=2')
                return 90 - angle
            }
        } else {
            if (y < 0) {
                // 3
                // console.log('=3')
                return 90 - angle
            } else {
                // 4
                // console.log('=4')
                return 360 + (90 - angle)
            }
        }
    }

    console.log('getAngle', getAngle(0, -100))

    class Point {
        constructor(x, y) {
            this.x = x
            this.y = y
        }
    }

    class Line {
        
        constructor(pt1, pt2) {
            this.pt1 = pt1
            this.pt2 = pt2
        }

        getX(y) {
            return (y - this.pt2.y) / (this.pt1.y - this.pt2.y) * (this.pt1.x - this.pt2.x) + this.pt2.x
        }

        getY(x) {
            return (x - this.pt2.x) / (this.pt1.x - this.pt2.x) * (this.pt1.y - this.pt2.y) + this.pt2.y
        }
    }

    let canvas = document.getElementById('canvas')
    let ctx = canvas.getContext('2d')


    let area = {
        x: 300,
        y: 0,
        width: 800 - 300,
        height: 800
    }
    let startPt2 = {
        x: 500,
        y: 300
    }

    function reDraw() {
        ctx.clearRect(0, 0, 800, 800)
        // 顶部
        let topLeft = 100
        let topTop = 100
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(topLeft, topTop)
        ctx.lineTo(topLeft + 200, topTop)
        ctx.stroke()
        for (let i = 0; i < 6; i++) {
            ctx.beginPath()
            ctx.moveTo(topLeft + 15 * (i + 1), topTop)
            ctx.lineTo(topLeft + 15 * (i + 1) + 10, topTop - 10)
            ctx.stroke()
            // cxt.line
        }
    
        let center = {
            x: topLeft + 100,
            y: topTop + 100
        }
        
    
        // ctx.beginPath()
        // ctx.arc(center.x, center.y, 4, 0, 1 * Math.PI)
        // ctx.stroke()
    
        // ctx.beginPath()
        // ctx.moveTo(center.x - 4, topTop)
        // ctx.lineTo(center.x - 4, center.y)
        // ctx.stroke()
        
    
        let radius = 30
        
    
        
        
    
        
        
    
        
    
    
        
        // ctx.beginPath()
        // ctx.arc(endPt.x, endPt.y, radius, 0, 2 * Math.PI)
        // ctx.stroke()
    
        
    
        // radius
        // 斜边
        let length = Math.sqrt(Math.pow(center.x - startPt2.x, 2) + Math.pow(center.y - startPt2.y, 2))
        console.log('length', length)
    
        // 直角边
        let length2 = Math.sqrt(Math.pow(length, 2) - Math.pow(radius, 2))
        console.log('length2', length2)
    
    
        // 1
        let angle1 = getAngle(startPt2.x - center.x, startPt2.y - center.y)
        console.log('angle1', angle1)
        // let angle2 = 
        let aaa = (Math.pow(radius, 2) + Math.pow(length, 2) - Math.pow(length2, 2)) / (2 * radius * length)
        // let aaa = (Math.pow(3, 2) + Math.pow(5, 2) - Math.pow(4, 2)) / (2 * 3 * 5)
    
        console.log('aaa', aaa)
    
        let ccc = Math.acos(aaa) * 180 / Math.PI
        console.log('ccc', ccc)
    
        let bbb = Math.cos(53.1301 / 180 * Math.PI) 
        console.log('bbb', bbb)
    
    
        let a = (angle1 + ccc - 90) * -1
        console.log('a', a)
        // a = -45
        let x1 = center.x + radius * Math.cos(a * Math.PI / 180)
        let y1 = center.y + radius * Math.sin(a * Math.PI / 180) 
    
        // let x1 = 0 + 100 * Math.cos(45 * Math.PI / 180)
        // let y1 = 0 + 100 * Math.sin(45 * Math.PI / 180) 
        console.log('xy', x1, y1)
    
        let ropeCenterLength = 20
        let ropeRightLength = length2
        // let huLength = 20
        let ropeLength = 500
        
        let boxWidth = radius * 2
        let boxHeight = radius * 2
    
        let ropeLeftLength = ropeLength - ropeRightLength - ropeCenterLength
        let isZhi = true
        let offset = ropeLeftLength - (300 - boxHeight)
        if (ropeLeftLength > 300 - boxHeight) {
            ropeLeftLength = 300 - boxHeight
            isZhi = false
            console.log('offset', offset)
        }
        
    
    
        let endPt = {
            x: center.x - radius,
            y: center.y
        }
        let endPt2 = {
            x: endPt.x,
            y: endPt.y + ropeLeftLength
        }
        ctx.lineWidth = 1
        if (isZhi) {
            ctx.beginPath()
            ctx.moveTo(endPt.x, endPt.y)
            ctx.lineTo(endPt2.x, endPt2.y)
            ctx.stroke()
        } else {
            let endCenterPt = {
                x: endPt.x - offset / 48 * 20,
                y: (endPt.y + endPt2.y) / 2
            }
            ctx.beginPath()
            ctx.moveTo(endPt.x, endPt.y)
            ctx.bezierCurveTo(endPt.x, endPt.y, endCenterPt.x, endCenterPt.y, endPt2.x, endPt2.y)
            ctx.stroke()
        }
        
    
    
        
        ctx.beginPath()
        ctx.rect(endPt2.x - boxWidth / 2, endPt2.y, boxWidth, boxHeight)
        ctx.stroke()
    
        
        
        // cosA=(b^2+c^2-a^2)/(2bc) 
    
        let startPt = {
            x: x1,
            y: y1
        }
        if (isZhi) {
            ctx.beginPath()
            ctx.moveTo(startPt.x, startPt.y)
            ctx.lineTo(startPt2.x, startPt2.y)
            ctx.stroke()
        } else {
            let startCenterPt = {
                x: (startPt.x + startPt2.x) / 2,
                y: (startPt.y + startPt2.y) / 2 + offset / 48 * 40,
                // 48
            }
            let startCenterPt2 = {
                x: startPt.x + offset / 70 * 10,
                y: startPt.y,
            }
            ctx.beginPath()
            ctx.moveTo(startPt.x, startPt.y)
            ctx.bezierCurveTo(startCenterPt2.x, startCenterPt2.y, startCenterPt.x, startCenterPt.y, startPt2.x, startPt2.y)
            ctx.stroke();
        }
        ctx.fillStyle = '#09c'
        ctx.beginPath()
        ctx.arc(startPt2.x, startPt2.y, 8, 0, 2 * Math.PI)
        // ctx.stroke()
        ctx.fill()
    
    
        console.log('测试', Math.tan(45 / 180 * Math.PI), Math.atan(1) * 180 / Math.PI)
    
    
        // 地板
        let groundCenter = {
            x: endPt.x,
            y: endPt.y + 300
        }
        ctx.beginPath()
        ctx.moveTo(groundCenter.x - 100, groundCenter.y)
        ctx.lineTo(groundCenter.x + 100, groundCenter.y)
        ctx.stroke()

    
        // 滑轮
        ctx.beginPath()
        ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI)
        ctx.fillStyle = '#fff'
        ctx.fill()
        ctx.stroke()
        // 杆
        ctx.beginPath()
        ctx.moveTo(center.x + 4, topTop)
        ctx.lineTo(center.x + 4, center.y)
        ctx.arcTo(center.x, center.y + 4, center.x - 4, center.y, 4)
        ctx.lineTo(center.x - 4, topTop)
        ctx.closePath()
        ctx.fillStyle = '#fff'
        ctx.fill()
        ctx.stroke()

        // 文字
        ctx.fillStyle = '#333'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        ctx.font = 'bold 16px sans-serif'
        ctx.fillText('1 kg', endPt2.x, endPt2.y + boxHeight / 2)
    
        
        ctx.beginPath()
        ctx.rect(area.x, area.y, area.width, area.height)
        ctx.stroke()

        // g=9.83N/kg
        // G=m*g 或 W=m*g
        let g = 9.83
        let m = 1
        let G = isZhi ? (m * g) : 0
        ctx.fillStyle = '#333'
        ctx.textAlign = 'left'
        ctx.textBaseline = 'middle'
        ctx.font = 'bold 16px sans-serif'
        ctx.fillText(`拉力 = ${G}N`, 16, 16)

    }


    reDraw()


    let isDown = false
    canvas.addEventListener('mousedown', function (e) {
        isDown = true
        console.log(e.pageX)
        console.log(e.pageY)
        let x = e.pageX
        let y = e.pageY
        startPt2 = {
            x,
            y
        }
        reDraw()
    })
    canvas.addEventListener('mousemove', function (e) {
        if (!isDown) {
            return
        }
        console.log(e.pageX)
        console.log(e.pageY)
        let x = e.pageX
        let y = e.pageY
        startPt2 = {
            x,
            y
        }
        reDraw()
    })
    canvas.addEventListener('mouseup', function (e) {
        isDown = false
    })



    
    // ctx.globalCompositeOperation = 'lighter'
    // Mirror
    // let planarMirror = {
    //     x: 300,
    //     y: 400,
    //     width: 200,
    //     height: 4
    // }
    // ctx.beginPath()
    // ctx.rect(planarMirror.x, planarMirror.y, planarMirror.width, planarMirror.height)
    // ctx.fillStyle = '#09c'
    // // ctx.fill()
    // ctx.stroke()
    // // flashlight
    // let flashlight = {
    //     x: 100,
    //     y: 0,
    //     width: 100,
    //     height: 200
    // }
    // ctx.beginPath()
    // ctx.rect(flashlight.x, flashlight.y, flashlight.width, flashlight.height)
    // ctx.lineWidth = 4
    // ctx.fillStyle = '#09c'
    // ctx.stroke()
    // ctx.fill()

    // let pt1 = {
    //     x: flashlight.x,
    //     y: flashlight.y
    // }
    // let pt2 = {
    //     x: flashlight.x + flashlight.width,
    //     y: flashlight.y + flashlight.height
    // }
    // let lightLine = new Line(pt1, pt2)

    // // (y - pt2.y) / (pt1.y - pt2.y) = (x - pt2.x) / (pt1.x - pt2.x)
    // // let y = (300 - pt2.x) / (pt1.x - pt2.x) * (pt1.y - pt2.y) + pt2.y
    // // console.log('y', y)
    // let crossX = lightLine.getX(400)
    // console.log('crossX', crossX)
    // let lines = [
    //     {
    //         x: 0,
    //         y: 0
    //     },
    //     {
    //         x: 300,
    //         y: 300
    //     },
    //     {
    //         x: 100,
    //         y: 400
    //     },
    // ]
    // if (crossX >= planarMirror.x && crossX <= planarMirror.x + planarMirror.width) {
    //     console.log('交叉')
    //     let pt3 = {
    //         x: crossX + 100,
    //         y: lightLine.getY(crossX - 100)
    //     }
    //     let pt4 = {
    //         x: crossX + 200,
    //         y: lightLine.getY(crossX - 200)
    //     }
    //     console.log('pt3', pt3)
    //     console.log('pt4', pt4)
    //     let lightLine2 = new Line(pt3, pt4)
    //     console.log('啊啊啊', lightLine2.getX(0))

    //     lines = [
    //         {
    //             x: flashlight.x,
    //             y: flashlight.y
    //         },
    //         {
    //             x: lightLine.getX(400),
    //             y: 400
    //         },
    //         {
    //             x: lightLine2.getX(0),
    //             y: 0
    //         },
    //     ]
    // } else {
    //     console.log('没有交叉')
    //     lines = [
    //         {
    //             x: flashlight.x,
    //             y: flashlight.y
    //         },
    //         {
    //             x: lightLine.getX(800),
    //             y: 800
    //         },
    //     ]
    // }

    

    // // light
    // ctx.strokeStyle = '#f00'
    // ctx.beginPath()
    // ctx.moveTo(lines[0].x, lines[0].y)
    // for (let i = 1; i < lines.length; i++) {
    //     ctx.lineTo(lines[i].x, lines[i].y)
    // }
    // ctx.lineWidth = 4
    // ctx.stroke()
    
    
</script>
</body>
</html>